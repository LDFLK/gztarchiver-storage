name: gztarchiver

on:
  schedule:
    - cron: "0 */6 * * *"  # every 6 hours
  workflow_dispatch:        # allows manual trigger

jobs:
  run-archiver:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout storage repo
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.TARGET_REPO_PAT }}
       
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"
       
      - name: Install archiver package
        run: pip install git+https://github.com/yasandu0505/gztarchiver.git
       
      - name: Create config.yaml from secret
        run: |
          echo "${{ secrets.GZTARCHIVER_CONFIG }}" > config.yaml
       
      - name: Calculate cycle and run archiver
        run: |
          # Define entries to cycle through - mix of years and specific dates
          # Format: "YEAR" for year-only or "YEAR MONTH DAY" for specific dates
          declare -a ENTRIES=(
            "2015"
            "2016"
            "2017"
            "2018"
            "2019"
            "2020"
            "2021"
            "2022"
            "2023"
            "2024"
          )
          
          # Calculate which entry to use based on current time
          # This creates a cycle that changes every 6 hours
          CURRENT_HOUR=$(date +%H)
          CURRENT_DAY=$(date +%j)  # day of year (1-366)
          
          # Create a unique index that changes every 6 hours
          CYCLE_INDEX=$(( (CURRENT_DAY * 4 + CURRENT_HOUR / 6) % ${#ENTRIES[@]} ))
          
          # Get the entry for this cycle
          ENTRY=${ENTRIES[$CYCLE_INDEX]}
          read -r YEAR MONTH DAY <<< "$ENTRY"
          
          echo "üïê Current cycle: $CYCLE_INDEX (of ${#ENTRIES[@]})"
          
          # Build the gztarchiver command based on entry type
          if [[ -n "$MONTH" && -n "$DAY" ]]; then
            echo "üìÖ Processing specific date: $YEAR-$MONTH-$DAY"
            gztarchiver --year $YEAR --month $MONTH --day $DAY --lang en --config config.yaml
          else
            echo "üìÖ Processing entire year: $YEAR"
            gztarchiver --year $YEAR --lang en --config config.yaml
          fi
          
          # Clean up metadata
          rm -rf metadata
       
      - name: Commit and push doc-archive
        run: |
          git config user.name "yasandu0505"
          git config user.email "yasanduyaka2005@gmail.com"
          git add doc-archive
          git commit -m "üîÑ Auto-update archive - $(date '+%Y-%m-%d %H:%M:%S')" || echo "No changes to commit"
          git push origin main 
             
      - name: Update README with status
        run: |
          # Get timestamp
          TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
          
          # Count documents
          TOTAL_DOCS=$(find doc-archive -type f -name "*.pdf" | wc -l)
          TOTAL_UNAVAILABLE=$(find doc-archive -type f -name "unavailable.txt" | wc -l)
          
          # Extract date range from directory structure or filenames
          if [ $TOTAL_DOCS -gt 0 ]; then
            # Get all dates from the archive structure and sort them
            ALL_DATES=$(find doc-archive -type f \( -name "*.pdf" -o -name "unavailable.txt" \) | \
              grep -oE '[0-9]{4}/[0-9]{2}/[0-9]{2}' | \
              sed 's|/|-|g' | \
              sort -u)
            
            if [ -n "$ALL_DATES" ]; then
              START_DATE=$(echo "$ALL_DATES" | head -1)
              END_DATE=$(echo "$ALL_DATES" | tail -1)
              DATE_RANGE="from $START_DATE to $END_DATE"
            else
              DATE_RANGE="date range unavailable"
            fi
          else
            DATE_RANGE=""
          fi
          
          # Generate per-year summary with both archived and unavailable docs
          SUMMARY_TABLE=$(
            # Get archived docs by year
            find doc-archive -type f -name "*.pdf" | awk -F'/' '{print $2}' | sort | uniq -c > /tmp/archived_counts.txt
            
            # Get unavailable docs by year  
            find doc-archive -type f -name "unavailable.txt" | awk -F'/' '{print $2}' | sort | uniq -c > /tmp/unavailable_counts.txt
            
            # Combine both counts by year
            awk '
            BEGIN { 
                while ((getline line < "/tmp/archived_counts.txt") > 0) {
                    split(line, a); archived[a[2]] = a[1]
                }
                while ((getline line < "/tmp/unavailable_counts.txt") > 0) {
                    split(line, u); unavailable[u[2]] = u[1]
                }
                close("/tmp/archived_counts.txt")
                close("/tmp/unavailable_counts.txt")
                
                # Get all years and sort them
                for (year in archived) years[year] = 1
                for (year in unavailable) years[year] = 1
                
                n = asorti(years, sorted_years)
                for (i = 1; i <= n; i++) {
                    year = sorted_years[i]
                    arch_count = (year in archived) ? archived[year] : 0
                    unav_count = (year in unavailable) ? unavailable[year] : 0
                    printf "| %s | %s | %s |\n", year, arch_count, unav_count
                }
            }'
          )
          
          # Calculate next scheduled entry for README
          declare -a ENTRIES=(
            "2015"
            "2016"
            "2017"
            "2018"
            "2019"
            "2020"
            "2021"
            "2022"
            "2023"
            "2024"
          )
          
          CURRENT_HOUR=$(date +%H)
          CURRENT_DAY=$(date +%j)
          CURRENT_CYCLE=$(( (CURRENT_DAY * 4 + CURRENT_HOUR / 6) % ${#ENTRIES[@]} ))
          NEXT_CYCLE=$(( (CURRENT_CYCLE + 1) % ${#ENTRIES[@]} ))
          NEXT_ENTRY=${ENTRIES[$NEXT_CYCLE]}
          
          # Format next entry for display
          read -r NEXT_YEAR NEXT_MONTH NEXT_DAY <<< "$NEXT_ENTRY"
          if [[ -n "$NEXT_MONTH" && -n "$NEXT_DAY" ]]; then
            NEXT_DISPLAY="$NEXT_YEAR-$NEXT_MONTH-$NEXT_DAY (specific date)"
          else
            NEXT_DISPLAY="$NEXT_YEAR (entire year)"
          fi
          
          # Write README.md
          cat <<EOF > README.md
          # Sri Lanka üá±üá∞ - Gazette Dataset
          
          Last Updated: $TIMESTAMP
          
          $TOTAL_DOCS documents, $DATE_RANGE.
    
          üêû #WorkInProgress - Suggestions, Questions, Ideas, Bug Reports are welcome!
          
          ---
          
          ## üìä Archive Status Dashboard
          
          **Last Archiver Run:** $TIMESTAMP  
          **Next Scheduled:** $NEXT_DISPLAY (in ~6 hours)
          
          **Summary of Documents Archived:**
          
          | Year | Archived Docs | Unavailable Docs |
          |------|---------------|-----------------|
          $SUMMARY_TABLE
          
          **Total Documents:** $TOTAL_DOCS  
          **Unavailable Documents:** $TOTAL_UNAVAILABLE 
          
          ---
          
          ### üîÑ Cycling Schedule (Every 6 Hours)
          The archiver alternates between full years and specific dates:
          
          **Full Years:** 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024 
          
          ---
          #Legal #OpenData #GovTech
          EOF
          
          # Commit and push README.md
          git config user.name "yasandu0505"
          git config user.email "yasanduyaka2005@gmail.com"
          git add README.md
          git commit -m "üìä Update status dashboard - $TIMESTAMP" || echo "No changes to commit"
          git push origin main --force